---
title: "Flickr Models"
output: github_document
bibliography: C:/Users/lg1u16/DATA/BIBLIOGRAPHY/library.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
```

```{r load_packages}
library(MASS)
library(raster)
library(sf)
library(tidyverse)
library(GGally)
library(broom)
library(MuMIn)
library(knitr)
library(hier.part)
library(patchwork)
library(corrr)
library(jtools)

# resolutions
rlns <- c("1km", "5km", "10km", "25km", "50km", "100km")

# study extent (for now this is England, will need extending to Europe)
study_ext_eng_sf <- st_read("~/DATA/ADMINISTRATIVE/gb_shapefile/GBR_adm1.shp", quiet = TRUE) %>% 
  filter(NAME_1 == "England") %>% 
  st_transform(crs = 3035)

study_ext_europe_sf <- st_read("~/DATA/ADMINISTRATIVE/europe/Europe_coastline.shp", quiet = TRUE) %>% 
  st_transform(crs = 3035)


study_ext_eng <- as(study_ext_eng_sf, "Spatial")
study_ext_europe <- as(study_ext_europe_sf, "Spatial")

theme_set(theme_bw(base_size = 10) + theme(strip.background = element_blank(), 
                             panel.grid.major = element_blank(),
                             panel.grid.minor = element_blank()))

# get the functions I've written for variance partitioning negative binomial models
source("code/hier.part.nb.R")
```

## Data collating

We're making one big dataframe of the response (Flickr photo locations) and covariates at each of the analysis resolutions and extents. 

Covariates are:

- Proportion of agricultural land cover (clc_agri; supply)
- Proporiton of natural land covers (clc_prop; supply)
- Diversity of land-cover types (clc_shei; supply)
- Mean elevation (dem_mean; supply)

```{r get_data}
get_df <- function(rln, study_ext) {
  # list all files of specified resolution
  fnames <- list.files("data/covariates", pattern = paste0("_", rln), full.names = TRUE)
  fnames <- c(fnames, paste0("data/response/flickr_", rln, ".tif"))
  
  # stack them
  dat <- stack(fnames)
  
  # crop by study extent
  dat <- crop(dat, study_ext)
  #dat <- mask(dat, study_ext)
  
  # get into a dataframe
  df <- as.data.frame(dat, xy = TRUE) %>% 
    rename_all(funs(str_replace_all(., paste0("_", rln), ""))) %>% 
    na.omit %>% 
    mutate(resolution = rln)
  
  return(df)
}

# dataframe with obs for all data
df_eng <- map_dfr(rlns, get_df, study_ext_eng) %>% 
  mutate(resolution = factor(resolution, 
                             levels = c("1km", 
                                        "5km", 
                                        "10km", 
                                        "25km", 
                                        "50km", 
                                        "100km")),
         extent = "England",
         clc_prop = clc_amenity + clc_forest + clc_veg + clc_water + clc_wetland) %>% 
  select(x, y, resolution, extent, flickr, clc_agri, 
         clc_prop, clc_shei, dem_mean, dem_var, pop) %>% 
  as_tibble()

df_europe <- map_dfr(rlns, get_df, study_ext_europe) %>% 
  mutate(resolution = factor(resolution, 
                             levels = c("1km", 
                                        "5km", 
                                        "10km", 
                                        "25km", 
                                        "50km", 
                                        "100km")),
         extent = "Europe",
         clc_prop = clc_amenity + clc_forest + clc_veg + clc_water + clc_wetland) %>% 
  select(x, y, resolution, extent, flickr, clc_agri, 
         clc_prop, clc_shei, dem_mean, dem_var, pop) %>% 
  as_tibble()

df <- bind_rows(df_eng, df_europe)

save(df, file = "flickr_df.Rda")
```

## Data exploration

### Distribution, sample size and coverage of the Flickr data

First, let's just see whether there is sufficient variability and n in each resolution to fit models. 

```{r flickr_distribution, fig.height = 3, fig.width = 8}
ggplot(df_eng, aes(x = flickr)) + 
  geom_histogram() + 
  facet_wrap(~resolution, scales = "free", nrow = 1)

ggplot(df_eng, aes(y = flickr)) + 
  geom_boxplot() + 
  facet_wrap(~resolution, scales = "free", nrow = 1)

ggplot(df_europe, aes(x = flickr)) + 
  geom_histogram() + 
  facet_wrap(~resolution, scales = "free", nrow = 1)

ggplot(df_europe, aes(y = flickr)) + 
  geom_boxplot() + 
  facet_wrap(~resolution, scales = "free", nrow = 1)
```

```{r flickr_n}
df %>% 
  group_by(extent, resolution) %>% 
  summarise(count = n())
```

Based on the distributions, we can fit models for all resolutions, but for the larger two (50km and 100km) at the smaller extent, n is small. 

We can also inspect the spatial coverage of the Flickr data. 

```{r flickr_spatial}
ggplot(df_eng, aes(x = x, y = y)) + 
  geom_raster() + 
  coord_equal() + 
  facet_wrap(~resolution) + 
  theme(axis.title = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank())

ggplot(df_europe, aes(x = x, y = y)) + 
  geom_raster() + 
  coord_equal() + 
  facet_wrap(~resolution) + 
  theme(axis.title = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank())
```

### Distribution of covariates

```{r cov_dist, fig.height = 3, fig.width = 8}
df_narrow_eng <- df_eng %>% 
  select(-x, -y, -flickr, -extent) %>% 
  gather(variable, value, -resolution) %>% 
  group_by(variable) %>% 
  nest() %>% 
  mutate(histograms = map2(variable, data, function(variable, data) {
    ggplot(data, aes(x = value)) + 
      geom_histogram() + 
      facet_wrap(~resolution, nrow = 1, scales = "free") +
      ggtitle(variable)
  }),
  boxplots = map2(variable, data, function(variable, data) {
    ggplot(data, aes(y = value)) + 
      geom_boxplot() + 
      facet_wrap(~resolution, nrow = 1, scales = "free") +
      ggtitle(variable)
  }))

df_narrow_europe <- df_europe %>% 
  select(-x, -y, -flickr, -extent) %>% 
  gather(variable, value, -resolution) %>% 
  group_by(variable) %>% 
  nest() %>% 
  mutate(histograms = map2(variable, data, function(variable, data) {
    ggplot(data, aes(x = value)) + 
      geom_histogram() + 
      facet_wrap(~resolution, nrow = 1, scales = "free") +
      ggtitle(variable)
  }),
  boxplots = map2(variable, data, function(variable, data) {
    ggplot(data, aes(y = value)) + 
      geom_boxplot() + 
      facet_wrap(~resolution, nrow = 1, scales = "free") +
      ggtitle(variable)
  }))

df_narrow_eng$histograms
df_narrow_eng$boxplots
df_narrow_europe$histograms
df_narrow_europe$boxplots
```

We'll log transform dem_mean, dem_var and pop. 

### Data scaling and transformation

```{r transform}
df_scaled <- df %>% group_by(resolution, extent) %>% 
  nest() %>% 
  mutate(#data = map(data, mutate_at, vars(dem_mean, dem_var, pop), 
          #          function(x) log(x + 1)),
         data_scale = map(data, mutate_at, vars(clc_agri:pop), 
                          function(x) scale(x) %>% as.vector)) 

df_analysis <- df_scaled %>% 
  select(resolution, extent, data_scale) %>% 
  unnest()

# get mean and sd values from the log-transformed data (for back scaling)
means <- df_scaled %>% 
  select(resolution, extent, data) %>% 
  unnest() %>% 
  group_by(resolution, extent) %>% 
  summarise_all(funs(mean, sd)) %>% 
  gather(key, value, -resolution, -extent) 
```

### Correlation between variables

```{r cov_corrs, fig.width = 10}
corrs <- df_analysis %>% 
  select(-x, -y) %>% 
  group_by(resolution, extent) %>% 
  nest() %>% 
  mutate(
    corrs = map(data, function(x) {
      x %>% correlate(quiet = TRUE)
    }),
    corrs2 = map(corrs, function(x) {
      x %>% rearrange %>% shave
    })
  )

map(corrs$corrs2, rplot, shape = 15, print_cor = TRUE)
```

And the relationship with the Flickr data: 

```{r flickr_corrs}
map(corrs$corrs, function(x) {
  x %>%
    focus(flickr) %>%
    mutate(rowname = reorder(rowname, flickr)) %>%
    ggplot(aes(rowname, flickr)) +
    geom_col() + 
    coord_flip() + 
    ylim(-1, 1)
})
```

Flickr data most strongly correlated with: 

```{r flickr_corr_shape}
df_narrow <- df_analysis %>% 
  select(-x, -y) %>% 
  gather(variable, value, -resolution, -extent, -flickr)


ggplot(df_narrow %>% filter(extent == "England"), 
       aes(x = value, y = flickr)) + 
  geom_point() + 
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs")) + 
  facet_grid(resolution ~ variable, scales = "free")

ggplot(df_narrow %>% filter(extent == "Europe"), 
       aes(x = value, y = flickr)) + 
  geom_point() + 
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs")) + 
  facet_grid(resolution ~ variable, scales = "free")
```

## Statistical Models

We will fit negative binomial GLMs (due to overdispersion) with proportion of non-built land cover (clc_prop), mean elevation (dem_mean) and population (pop) and their first-order interactions as the full model. 

We fit a negative binomial glm for each resolution with proportion of agricultural land covers; proportion of natural land covers; diversity of land cover; mean elevation; and population as covariates. 

We use variance partitioning to examing the relative importance of each predictor with the model. 

We measure model fit using $D^2$, which is equivalent to $R^2$ [@Guisan2000a]. Note also that due to the differences in sample size, $D^2$ values are not directly comparable.

```{r flickr_mods}
fit_mod_full <- function(dat) {
  glm.nb(flickr ~ clc_agri + clc_prop + clc_shei + dem_mean + pop,
      data = dat)
}

fit_mod_supply <- function(dat) {
  glm.nb(flickr ~ clc_agri + clc_prop + clc_shei + dem_mean,
      data = dat)
}

fit_mod_demand <- function(dat) {
  glm.nb(flickr ~ pop,
      data = dat)
}

part_var <- function(dat) {
  resp <- dat %>% pull(flickr)
  pred <- dat %>% dplyr::select(clc_agri, clc_prop, clc_shei, dem_mean, pop)
  part <- hier.part(resp, pred, family = "poisson", gof = "logLik", barplot = FALSE)$I.perc
  out <- tibble(var = rownames(part), expl = part$I)
}


part_var_nb <- function(dat) {
  resp <- dat %>% pull(flickr)
  pred <- dat %>% dplyr::select(clc_agri, clc_prop, clc_shei, dem_mean, pop)
  part <- hier.part.nb(resp, pred, gof = "logLik")$I.perc
  out <- tibble(var = rownames(part), expl = part$I)
}

# get all of the required stats
get_mod_stats <- function(mod) {
  coeff <- coef(mod)[-1] %>% 
    data.frame %>% 
    as_tibble(rownames = "variable") %>% 
    rename(coef = 2)
  
  conf <- confint(mod)[-1,] %>% 
    data.frame %>% 
    as_tibble(rownames = "variable") %>% 
    rename(lci = X2.5.., uci = X97.5..)
  
  out <- inner_join(coeff, conf)
  
  return(out)
}

# and now the predicted values for plotting the relationships
get_preds <- function(mod, res, extnt) {
  vars <- variable.names(mod)[-1]
  map_dfr(vars, function(variable) {
    var_mean <- means %>% 
      filter(resolution == res, extent == extnt, key == paste0(variable, "_mean")) %>% 
      pull(value)
    
    var_sd <- means %>% 
      filter(resolution == res, extent == extnt, key == paste0(variable, "_sd")) %>% 
      pull(value)
    
    preds <- make_predictions(mod, pred = variable, interval = TRUE)$predicted %>% 
      select(flickr, pred = !!variable, ymin, ymax) %>% 
      mutate(pred = pred*var_sd + var_mean,
             #pred = case_when(variable == "clc_agri" ~ sqrt(pred),
            #                  TRUE ~ exp(pred) - 1),
             variable = variable) %>% 
      na.omit()
    
    return(preds)
  })
}

mod <- df_analysis %>% 
  group_by(resolution, extent) %>% 
  nest() %>% 
  mutate(mod_full = map(data, fit_mod_full),
         mod_supply = map(data, fit_mod_supply),
         mod_demand = map(data, fit_mod_demand),
         mod_glance = map(mod_full, glance),
         mod_stats = map(mod_full, get_mod_stats),
         mod_part = map(data, part_var_nb),
         mod_resid = map(mod_full, resid),
         mod_fitted = map(mod_full, function(x) x$fitted),
         mod_preds = pmap(list(mod_full, as.character(resolution), extent), get_preds))

mod_D2 <- mod %>%
  select(resolution, extent, mod_glance) %>% 
  unnest() %>% 
  mutate(D2 = (null.deviance - deviance)/null.deviance) %>% 
  select(resolution, extent, D2)

mod_part <- mod %>% 
  dplyr::select(resolution, extent, mod_part) %>% 
  unnest()

mod_stats <- mod %>%
  dplyr::select(resolution, extent, mod_stats) %>% 
  unnest()

aic_table <- mod %>%
  mutate(mod_full_aic = map_dbl(mod_full, function(x) x$aic),
         mod_demand_aic = map_dbl(mod_demand, function(x) x$aic),
         mod_supply_aic = map_dbl(mod_supply, function(x) x$aic)) %>% 
  select(extent, resolution, mod_full_aic, mod_demand_aic, mod_supply_aic)
aic_table %>% kable()
write_csv(aic_table, "doc/table1_aiccomp.csv")
```


### Model Fit

```{r}
ggplot(mod_D2, aes(x = resolution, y = D2, group = 1)) + 
  geom_point() +
  facet_wrap(~extent) + 
  stat_summary(fun.y=sum, geom="line")
```

Explanatory power of the model increases greatly between 1km and 5km resolutions (with increasing explanatory power as resolution increases, as to be expected). Might be best to drop the 1km model. 

### Variance partitioning

```{r}
p1 <- ggplot(mod_D2, aes(x = resolution, y = D2)) + 
  geom_bar(stat = "identity") + 
  labs(x = "", y = expression(D^{2})) + 
  facet_wrap(~extent) + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

p2 <- ggplot(mod_part, aes(x = resolution, y = expl, fill = var)) + 
  scale_fill_brewer(palette = "Set1", name = "Variable") + 
  geom_bar(stat = "identity", position = "stack") + 
  facet_wrap(~extent)
  labs(x = "Resolution", y = "Variance explained %")

p1 + p2 + 
  plot_layout(ncol = 1, heights = c(1, 3)) + 
  plot_annotation(tag_levels = "a", tag_suffix = ")")
```

### Variable relationships

```{r coeff_plots_england, fig.height = 10, fig.width=8}
mod_preds <- mod %>%
  select(resolution, extent, mod_preds) %>% 
  filter(extent == "England") %>% 
  unnest() %>% 
  group_by(resolution, variable) %>% 
  ungroup() %>% 
  group_by(resolution) %>% 
  nest() %>% 
  mutate(plots = map2(data, resolution, function(dat, res) {
    ggplot(dat, aes(x = pred, y = flickr)) +
      geom_line(aes()) + 
      geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) +
      facet_wrap(~variable, nrow = 1, scale = "free_x") + 
      ggtitle(res)
  }))
  
mod_preds$plots[[1]] + mod_preds$plots[[2]] + mod_preds$plots[[3]] + mod_preds$plots[[4]] + mod_preds$plots[[5]] + mod_preds$plots[[6]] + plot_layout(ncol = 1)
```

```{r coeff_plots_europe, fig.height = 10, fig.width=8}
mod_preds <- mod %>%
  select(resolution, extent, mod_preds) %>% 
  filter(extent == "Europe") %>% 
  unnest() %>% 
  group_by(resolution, variable) %>% 
  ungroup() %>% 
  group_by(resolution) %>% 
  nest() %>% 
  mutate(plots = map2(data, resolution, function(dat, res) {
    ggplot(dat, aes(x = pred, y = flickr)) +
      geom_line(aes()) + 
      geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) +
      facet_wrap(~variable, nrow = 1, scale = "free_x") + 
      ggtitle(res)
  }))
  
mod_preds$plots[[1]] + mod_preds$plots[[2]] + mod_preds$plots[[3]] + mod_preds$plots[[4]] + mod_preds$plots[[5]] + mod_preds$plots[[6]] + plot_layout(ncol = 1)
```

Alternatively, we can plot the coefficients rather than the fitted relationships:

```{r}
mod_coeffs <- mod %>%
  select(resolution, extent, mod_preds) %>% 
  filter(extent == "England") %>% 
  unnest() %>% 
  group_by(resolution, variable) %>% 
  ungroup() %>% 
  group_by(resolution) %>% 
  nest() %>% 
  mutate(plots = map2(data, resolution, function(dat, res) {
    ggplot(dat, aes(x = pred, y = flickr)) +
      geom_line(aes()) + 
      geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) +
      facet_wrap(~variable, nrow = 1, scale = "free_x") + 
      ggtitle(res)
  }))
```

### Model checking

```{r}
library(DHARMa)
for(i in 1:nrow(mod)) {
  print(mod$extent[[i]])
  print(mod$resolution[[i]])
  simulationOutput <- simulateResiduals(fittedModel = mod$mod_full[[i]], n = 250)
  par(mfrow=c(1,1))
  plot(simulationOutput)
  testDispersion(simulationOutput, alternative = "greater")
  par(mfrow=c(2, 3))
  plotResiduals(mod$data[[i]]$clc_agri, simulationOutput$scaledResiduals, xlab = "clc_agri")
  plotResiduals(mod$data[[i]]$clc_prop, simulationOutput$scaledResiduals, xlab = "clc_prop")
  plotResiduals(mod$data[[i]]$clc_shei, simulationOutput$scaledResiduals, xlab = "clc_shei")
  plotResiduals(mod$data[[i]]$dem_mean, simulationOutput$scaledResiduals, xlab = "dem_mean")
  plotResiduals(mod$data[[i]]$pop, simulationOutput$scaledResiduals, xlab = "pop")
}

```

## Bright & Dark spots
## References

## Session Info

```{r session_info}
session <- devtools::session_info()
session[[1]]
session[[2]] %>% kable
```