---
title: "MENE Models"
output: github_document
bibliography: C:/Users/lg1u16/DATA/BIBLIOGRAPHY/library.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
```

```{r load_packages}
library(e1071) # optimising transformations (skewness function)
library(MASS)
library(raster)
library(sf)
library(tidyverse)
library(GGally)
library(broom)
library(MuMIn)
library(knitr)
library(hier.part)
library(patchwork)
library(corrr)
library(jtools)

# resolutions
rlns <- c("1km", "5km", "10km", "25km", "50km", "100km")

# study extent (for MENE this is England)
study_ext_sf <- st_read("~/DATA/ADMINISTRATIVE/gb_shapefile/GBR_adm1.shp", quiet = TRUE) %>% 
  filter(NAME_1 == "England") %>% 
  st_transform(crs = 3035)

study_ext <- as(study_ext_sf, "Spatial")

theme_set(theme_bw(base_size = 10) + theme(strip.background = element_blank(), 
                             panel.grid.major = element_blank(),
                             panel.grid.minor = element_blank()))

# get the functions I've written for variance partitioning negative binomial models
source("code/hier.part.nb.R")
```

## Data collating

We're making one big dataframe of the response (MENE visits) and  covariates (proportion of non-built land covers, land-cover diversity, mean elevation, topographic variation and population density) at each of the analysis resolutions. 

```{r get_data}
get_df <- function(rln) {
  # list all files of specified resolution
  fnames <- list.files("data/covariates", pattern = paste0("_", rln), full.names = TRUE)
  fnames <- c(fnames, paste0("data/response/mene_", rln, ".tif"))
  
  # stack them
  dat <- stack(fnames)
  
  # crop and mask by study extent - mask will get rid of most of the coastal cells
  # NB need to find out what rule mask actually applies
  dat <- crop(dat, study_ext)
  dat <- mask(dat, study_ext)
  
  # get into a dataframe
  df <- as.data.frame(dat, xy = TRUE) %>% 
    rename_all(funs(str_replace_all(., paste0("_", rln), ""))) %>% 
    na.omit %>% 
    mutate(resolution = rln)
  
  return(df)
}

# dataframe with obs for all data
df <- map_dfr(rlns, get_df) %>% 
  mutate(resolution = factor(resolution, 
                             levels = c("1km", 
                                        "5km", 
                                        "10km", 
                                        "25km", 
                                        "50km", 
                                        "100km")),
         clc_prop = clc_amenity + clc_forest + clc_veg + clc_water + clc_wetland) %>% 
  select(x, y, resolution, mene, clc_agri, clc_prop, clc_shei, dem_mean, dem_var, pop) %>% 
  as_tibble()
```

## Data exploration

### Distribution, sample size and coverage of MENE data

First, let's just see whether there is sufficient variability and n in each resolution to fit models. 

```{r mene_distribution, fig.height = 3, fig.width = 8}
ggplot(df, aes(x = mene)) + 
  geom_histogram() + 
  facet_wrap(~resolution, scales = "free", nrow = 1)

ggplot(df, aes(y = mene)) + 
  geom_boxplot() + 
  facet_wrap(~resolution, scales = "free", nrow = 1)
```

```{r mene_n}
df %>% 
  group_by(resolution) %>% 
  summarise(count = n())
```

Based on the distributions, we can fit models for all resolutions, but for the larger two (50km and 100km), n is very small. 

We can also inspect the spatial coverage of the MENE data. 

```{r mene_spatial}
ggplot(df, aes(x = x, y = y)) + 
  geom_raster() + 
  coord_equal() + 
  facet_wrap(~resolution) + 
  theme(axis.title = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank())
```

Sparse coverage at 1km and 5km, but not too geographically biased. There are a lot of records around London, and to some extent within National Parks. This may cause some issues, but will see. 

### Distribution of covariates

```{r cov_dist, fig.height = 3, fig.width = 8}
df_narrow <- df %>% 
  select(-x, -y, -mene) %>% 
  gather(variable, value, -resolution) %>% 
  group_by(variable) %>% 
  nest() %>% 
  mutate(histograms = map2(variable, data, function(variable, data) {
    ggplot(data, aes(x = value)) + 
      geom_histogram() + 
      facet_wrap(~resolution, nrow = 1, scales = "free") +
      ggtitle(variable)
  }),
  boxplots = map2(variable, data, function(variable, data) {
    ggplot(data, aes(y = value)) + 
      geom_boxplot() + 
      facet_wrap(~resolution, nrow = 1, scales = "free") +
      ggtitle(variable)
  }))

df_narrow$histograms
df_narrow$boxplots
```

- clc_agri: left skew at all resolutions but 1km and 100km
- clc_prop: right skew at all resolutions
- clc_shei: fine
- dem_mean: right skew at all resolutions but 100km
- dem_var: right skew at all resolutions but 100km
- pop: right skew at all resolutions

### Data scaling and transformation

Currently the transformations are commented out. Will need to check at the linearity checking and model checking stages. 

```{r transform}
df_scaled <- df %>% group_by(resolution) %>% 
  nest() %>% 
  mutate(data = map(data, mutate_at, vars(clc_prop:pop), function(x) log(x + 1)),
         data = map(data, mutate, clc_agri = clc_agri^2),
         data_scale = map(data, mutate_at, vars(clc_agri:pop), function(x) scale(x) %>% as.vector)) 

df_analysis <- df_scaled %>% 
  select(resolution, data_scale) %>% 
  unnest()

# get mean and sd values from the log-transformed data (for back scaling)
means <- df_scaled %>% 
  select(resolution, data) %>% 
  unnest() %>% 
  group_by(resolution) %>% 
  summarise_all(funs(mean, sd)) %>% 
  gather(key, value, -resolution) 
# %>% 
  # separate(key, into=c("covariate", "measure")) %>% 
  # spread(measure, value)
```

### Correlation between variables

```{r cov_corrs, fig.width = 10}
corrs <- df_analysis %>% 
  select(-x, -y) %>% 
  group_by(resolution) %>% 
  nest() %>% 
  mutate(
    corrs = map(data, function(x) {
      x %>% correlate(quiet = TRUE)
    }),
    corrs2 = map(corrs, function(x) {
      x %>% rearrange %>% shave
    })
  )

map(corrs$corrs2, rplot, shape = 15, print_cor = TRUE)
```

There are some high correlations here. Will likely cause issues for the coarser resolutions. Need to keep an eye on the estimates. 

And the relationship with MENE: 

```{r mene_corrs}
map(corrs$corrs, function(x) {
  x %>%
    focus(mene) %>%
    mutate(rowname = reorder(rowname, mene)) %>%
    ggplot(aes(rowname, mene)) +
    geom_col() + 
    coord_flip() + 
    ylim(-1, 1)
})
```

MENE most strongly correlated with:

- 1km: agriculture (-ve), population and proportion of natural land covers (+ve)
- 5km: agriculture (-ve), population and land-cover diversity (+ve)
- 10km: agriculture and mean elevation (-ve), land-cover diversity and population (+ve)
- 25km: agriculture and mean elevation (-ve), land-cover diversity andpopulation  (+ve)
- 50km: agriculture, proportion of natural land covers and mean (& var) elevation  (-ve), land-cover diversity and population (+ve)
- 100km: proportion of natural land covers (-ve), land-cover diversity, population and agriculture (+ve)

On the whole, using bivariate correlations, proportion of natural land covers goes from a positive correlation to a negative correlation across scales. Agriculture vice-versa. Population and land-cover diversity always positive (although the latter marginally negative at 1km resolution). Finally, given the high correlation between mean and variance of elevation, we will retain mean elevation given it's stronger bivariate correlation with MENE.  

What are the shapes of the correlations between MENE and covariates:

```{r mene_corr_shape}
df_analysis %>% 
  select(-x, -y) %>% 
  gather(variable, value, -resolution, -mene, -dem_var) %>% 
  ggplot(aes(x = value, y = mene)) + 
  geom_point() + 
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs")) + 
  facet_grid(resolution ~ variable, scales = "free")
```

No huge departures from linearity, might want to check against mean elevation (dem_mean) and land-cover diversity (clc_shei) in final model. 

## Statistical Models

We fit a Poisson glm for each resolution with proportion of agricultural land covers; proportion of natural land covers; diversity of land cover; mean elevation; and population as covariates. 

We use variance partitioning to examing the relative importance of each predictor with the model. 

We measure model fit using $D^2$, which is equivalent to $R^2$ [@Guisan2000a]. Note also that due to the differences in sample size, $D^2$ values are not directly comparable.

```{r mene_mods}
fit_mod_full <- function(dat) {
  glm.nb(mene ~ clc_agri + clc_prop + clc_shei + dem_mean + pop,
      #family = "poisson",
      data = dat)
}

fit_mod_supply <- function(dat) {
  glm.nb(mene ~ clc_agri + clc_prop + clc_shei + dem_mean,
      #family = "poisson",
      data = dat)
}

fit_mod_demand <- function(dat) {
  glm.nb(mene ~ pop,
      #family = "poisson",
      data = dat)
}

part_var <- function(dat) {
  resp <- dat %>% pull(mene)
  pred <- dat %>% dplyr::select(clc_agri, clc_prop, clc_shei, dem_mean, pop)
  part <- hier.part(resp, pred, family = "poisson", gof = "logLik", barplot = FALSE)$I.perc
  out <- tibble(var = rownames(part), expl = part$I)
}


part_var_nb <- function(dat) {
  resp <- dat %>% pull(mene)
  pred <- dat %>% dplyr::select(clc_agri, clc_prop, clc_shei, dem_mean, pop)
  part <- hier.part.nb(resp, pred, gof = "logLik")$I.perc
  out <- tibble(var = rownames(part), expl = part$I)
}

# get all of the required stats
get_mod_stats <- function(mod) {
  coeff <- coef(mod)[-1] %>% 
    data.frame %>% 
    as_tibble(rownames = "variable") %>% 
    rename(coef = 2)
  
  conf <- confint(mod)[-1,] %>% 
    data.frame %>% 
    as_tibble(rownames = "variable") %>% 
    rename(lci = X2.5.., uci = X97.5..)
  
  out <- inner_join(coeff, conf)
  
  return(out)
}

# and now the predicted values for plotting the relationships
get_preds <- function(mod, res) {
  vars <- variable.names(mod)[-1]
  map_dfr(vars, function(variable) {
    var_mean <- means %>% 
      filter(resolution == res, key == paste0(variable, "_mean")) %>% 
      pull(value)
    
    var_sd <- means %>% 
      filter(resolution == res, key == paste0(variable, "_sd")) %>% 
      pull(value)
    
    preds <- make_predictions(mod, pred = variable, interval = TRUE)$predicted %>% 
      select(mene, pred = !!variable, ymin, ymax) %>% 
      mutate(pred = pred*var_sd + var_mean,
             pred = case_when(variable == "clc_agri" ~ sqrt(pred),
                              TRUE ~ exp(pred) - 1),
             variable = variable) %>% 
      na.omit()
    
    return(preds)
  })
}

mod <- df_analysis %>% 
  group_by(resolution) %>% 
  nest() %>% 
  mutate(mod_full = map(data, fit_mod_full),
         mod_supply = map(data, fit_mod_supply),
         mod_demand = map(data, fit_mod_demand),
         mod_glance = map(mod_full, glance),
         mod_stats = map(mod_full, get_mod_stats),
         mod_part = map(data, part_var_nb),
         mod_resid = map(mod_full, resid),
         mod_fitted = map(mod_full, function(x) x$fitted),
         mod_preds = map2(mod_full, resolution, get_preds))

mod_D2 <- mod %>%
  dplyr::select(resolution, mod_glance) %>% 
  unnest() %>% 
  mutate(D2 = (null.deviance - deviance)/null.deviance) %>% 
  dplyr::select(resolution, D2)

mod_part <- mod %>% 
  dplyr::select(resolution, mod_part) %>% 
  unnest()

mod_stats <- mod %>%
  dplyr::select(resolution, mod_stats) %>% 
  unnest()

mod %>%
  mutate(mod_full_aic = map_dbl(mod_full, function(x) x$aic),
         mod_demand_aic = map_dbl(mod_demand, function(x) x$aic),
         mod_supply_aic = map_dbl(mod_supply, function(x) x$aic)) %>% 
  select(resolution, mod_full_aic, mod_demand_aic, mod_supply_aic) %>% 
  kable()
```

In all cases except 50km resolution the full (supply & demand) model is the best performing model as judged by AIC. At 50km resolution, technically the demand model would be judged the best model; however, there is very little in it. In all cases except 1km resolution, the demand model is better than the supply model. This fits with our later conclusions about the 1km model not really capturing demand at the appropriate scale. 

### Model Fit

```{r}
ggplot(mod_D2, aes(x = resolution, y = D2, group = 1)) + 
  geom_point() + 
  stat_summary(fun.y=sum, geom="line")
```

Explanatory power of the model increases greatly between 1km and 5km resolutions (with increasing explanatory power as resolution increases, as to be expected). Might be best to drop the 1km model. The lack of explanatory power in the 1km model does lend itself to the suggestion that at fine resolutions, we need to consider more bespoke options. Also, this likely has a lot to do with the scale of both supply and demand (e.g. point-based models of recreation will consider buffers around points to capture this). 

### Variance partitioning

Using package `hier.part`

```{r}
p1 <- ggplot(mod_D2, aes(x = resolution, y = D2)) + 
  geom_bar(stat = "identity") + 
  labs(x = "", y = expression(D^{2})) + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

p2 <- ggplot(mod_part, aes(x = resolution, y = expl, fill = var)) + 
  scale_fill_brewer(palette = "Set1", name = "Variable") + 
  geom_bar(stat = "identity", position = "stack") + 
  labs(x = "Resolution", y = "Variance explained %")

p1 + p2 + 
  plot_layout(ncol = 1, heights = c(1, 3)) + 
  plot_annotation(tag_levels = "a", tag_suffix = ")")
```

(note to self: these colours look hateful, but we can tell them apart and I've checked with a colourblindness simulator)

- Importance of population increases with spatial resolution until 100km, where it decreases again. This explains the most variation in all cases except at 1km resolution. Suggests that people are travelling further than 1km on average?
- Importance of agriculture decreases with spatial resolution (slight increase at 100km)
- Mean elevation is most important at 1km resolution, reasonably stable thereafter
- Importance of land-cover diversity increases with spatial resolution (ish)
- Importance of proportion of natural land covers increases with spatial resolution, but is highest at 1km resolution, which doesn't fit the pattern. 
- We can also view as categories - here orange is demand, everything else is supply. Importance of demand increases with spatial resolution (supply higher importance at fine resolutions, which also makes sense given the comment about travel distance)

### Variable relationships

```{r coeff_plots, fig.height = 10, fig.width=8}
mod_preds <- mod %>%
  select(resolution, mod_preds) %>% 
  unnest() %>% 
  group_by(resolution, variable) %>% 
  ungroup() %>% 
  group_by(resolution) %>% 
  nest() %>% 
  mutate(plots = map2(data, resolution, function(dat, res) {
    ggplot(dat, aes(x = pred, y = mene)) +
      geom_line(aes()) + 
      geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) +
      facet_wrap(~variable, nrow = 1, scale = "free_x") + 
      ggtitle(res)
  }))
  
mod_preds$plots[[1]] + mod_preds$plots[[2]] + mod_preds$plots[[3]] + mod_preds$plots[[4]] + mod_preds$plots[[5]] + mod_preds$plots[[6]] + plot_layout(ncol = 1)
```

NB BELOW TEXT NEEDS UPDATING TO REFER TO THESE NEW PLOTS. 

**I'm trying to work out what to do about these. If I exclude correlated variable I end up with none of my models meeting assumptions. The multicollinearity doesn't affect the variance partitioning due to the way in which this has been done; however, it does affect the ability to estimate parameters. Thing is, I'm not actually sure I 100% care about that**

- Agricultural land covers negative at fine resolutions, crossing over to positive. So when it's an important predictor, it generally has a negative effect. 
- Natural land covers have a positive effect on recreation at all resolutions, with this effect increasing with resolution (large CIs notwithstanding - i.e. non-sig at 25, 50 and possibly 10km resolution). 
- Land-cover diversity has a negative effect the strongest effect on recreation at intermediate resolutions. This makes sense because at fine resolutions, we are unlikely to have more than a few land-cover types represented and therefore it will generally always be low. At coarse resolutions, the smoothing effect of averaging will mean that there is more within-unit diversity than among-unit diversity. This is an argument for using the grainchanger method at such scales (it also provides us with a good estimate of the resolutions at which it's required). 
- Mean elevation is generally negative and stable across scales, switches to positive at 100km (need to examine 100km elevation map to think about why). 
- Effect of population is also reasonably stable except at 100km. 100km results are likely very influenced by the small sample size and high correlations between variables. 

NB Since changing to negative binomial model, these estimates are far less precise. Conclusions still roughly as above though. 

### Model checking

```{r}
library(DHARMa)
for(i in 1:6) {
  print(mod$resolution[[i]])
  simulationOutput <- simulateResiduals(fittedModel = mod$mod_full[[i]], n = 250)
  par(mfrow=c(1,1))
  plot(simulationOutput)
  testDispersion(simulationOutput, alternative = "greater")
  par(mfrow=c(2, 3))
  plotResiduals(mod$data[[i]]$clc_agri, simulationOutput$scaledResiduals, xlab = "clc_agri")
  plotResiduals(mod$data[[i]]$clc_prop, simulationOutput$scaledResiduals, xlab = "clc_prop")
  plotResiduals(mod$data[[i]]$clc_shei, simulationOutput$scaledResiduals, xlab = "clc_shei")
  plotResiduals(mod$data[[i]]$dem_mean, simulationOutput$scaledResiduals, xlab = "dem_mean")
  plotResiduals(mod$data[[i]]$pop, simulationOutput$scaledResiduals, xlab = "pop")
}

```

Interestingly, the model's only particularly well fitting at 10km and 25km resolution. I think that this is likely a discussion point? Based on the kind of model we are looking at, 10/25km resolution is the most appropriate analysis scale? 

## Bright & dark spots

Following Frei et al. [-@Frei2018] and Cinner et al. [-@Cinner2016], we calculate bright spots and dark spots. We define bright/dark spots as those where the observed value is +/- 1SD (of observed values) from the expected value. 

```{r, fig.width = 15, fig.height = 10}
bd_spots <- mod %>% 
  dplyr::select(resolution, data, mod_fitted, mod_resid) %>% 
  unnest() %>% 
  group_by(resolution) %>% 
  mutate(diff = mod_fitted - mene,
         bd_spots = case_when(diff < -sd(mene) ~ "Dark",
                               diff > sd(mene) ~ "Bright",
                               TRUE ~ "Neutral"))

# potentially explanatory spatial layers
# np <- st_read("~/DATA/ADMINISTRATIVE/national_parks_england/National_Parks_England.shp",
#               quiet = TRUE) %>%
#   st_transform(st_crs(study_ext_sf))
# 
# aonb <- st_read("~/DATA/ADMINISTRATIVE/aonb_england/Areas_of_Outstanding_Natural_Beauty_England.shp",
#                 quiet = TRUE) %>%
#   st_transform(st_crs(study_ext_sf))

cities <- st_read("~/DATA/ADMINISTRATIVE/uk_cities/Major_Towns_and_Cities_December_2015_Boundaries.shp",
                  quiet = TRUE) %>%
  st_transform(st_crs(study_ext_sf)) %>%
  st_centroid %>%
  filter(tcity15nm %in% c("Birmingham", "Leeds", "London", "Manchester", "Newcastle upon Tyne"))

ggplot() + 
  geom_raster(data = bd_spots, 
              aes(x = x, y = y, fill = bd_spots)) + 
  #geom_sf(data = np, colour = "black", fill = NA) + 
  #geom_sf(data = aonb, colour = "black", fill = NA) + 
  geom_sf(data = cities, colour = "black", fill = NA) + 
  geom_sf(data = study_ext_sf, fill = NA) + 
  facet_wrap(~resolution) + 
  scale_fill_manual(values = c("orange", "blue", "grey")) + 
  theme(axis.title = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank())
```

Cities marked out: London, Birmingham, Manchester, Leeds, Newcastle upon Tyne.  At the analysis scales with the best fitting models (10km/25km resolution), the bright/dark spots are clustered around London and Manchester. The latter likely representing the Peak District. 
```{r}
ggplot(bd_spots, aes(x = mod_fitted, y = mene)) + 
  geom_point(aes(colour = bd_spots)) + 
  scale_colour_manual(values = c("orange", "blue", "grey")) + 
  geom_smooth(method = "lm") + 
  facet_wrap(~resolution, scales = "free")
```

This pretty much shows that 1km is a poorly fitting model, need more bespoke approaches at this scale? 

Scale dependency in the % of bright/dark spots?

```{r}
bd_summary <- group_by(bd_spots, resolution) %>% 
  summarise(Bright = sum(bd_spots == "Bright"),
            Dark = sum(bd_spots == "Dark"),
            Total = n(),
            `Bright %` = (Bright/Total)*100,
            `Dark %` = (Dark/Total)*100) %>% 
  gather(key, value, -resolution, -Bright, -Dark, -Total)

ggplot(bd_summary, aes(x = resolution, y = value, colour = key, group = key)) + 
  geom_point() + 
  scale_colour_manual(values = c("orange", "blue", "grey")) + 
  stat_summary(fun.y=sum, geom="line") + 
  ylab("% of total area")
```

I'm not sure that this plot is useful - I think this just tells us the same as the increasing $R^2$. 

## Hot & cold spots

These are the areas of maximum and minimum service provision. I'm defining hot/cold spots as those cells in the top/bottom 5%. 

I'm not 100% convinced by this because of the skewed distribution. 

```{r}
hc_spots <- df %>% 
  group_by(resolution) %>% 
  mutate(hc_spots = case_when(mene < quantile(mene, 0.1) ~ "Cold",
                               mene > quantile(mene, 0.9) ~ "Hot",
                               TRUE ~ "Neutral"))
```

```{r}
ggplot() + 
  geom_raster(data = hc_spots, 
              aes(x = x, y = y, fill = hc_spots)) + 
  #geom_sf(data = np, colour = "black", fill = NA) + 
  #geom_sf(data = aonb, colour = "black", fill = NA) + 
  geom_sf(data = cities, colour = "black", fill = NA) + 
  geom_sf(data = study_ext_sf, fill = NA) + 
  facet_wrap(~resolution) + 
  scale_fill_manual(values = c("blue", "orange", "grey")) + 
  theme(axis.title = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank())
```

Problem in that coastal areas come out as cold spots, but that's an area thing. Might need to remove cells which are not 100% on land. 

Scale dependency in the % of hot/cold spots?

```{r}
hc_summary <- group_by(hc_spots, resolution) %>% 
  summarise(Hot = sum(hc_spots == "Hot"),
            Cold = sum(hc_spots == "Cold"),
            Total = n(),
            `Hot %` = (Hot/Total)*100,
            `Cold %` = (Cold/Total)*100) %>% 
  gather(key, value, -resolution, -Hot, -Cold, -Total)

ggplot(hc_summary, aes(x = resolution, y = value, colour = key, group = key)) + 
  geom_point() + 
  scale_colour_manual(values = c("blue", "orange", "grey")) + 
  stat_summary(fun.y=sum, geom="line") + 
  ylab("% of total area")
```


## References

## Session Info

```{r session_info}
session <- devtools::session_info()
session[[1]]
session[[2]] %>% kable
```