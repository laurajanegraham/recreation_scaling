---
title: "MENE Models"
output: github_document
bibliography: C:/Users/lg1u16/DATA/BIBLIOGRAPHY/library.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
```

```{r load_packages}
library(MASS)
library(raster)
library(sf)
library(tidyverse)
library(GGally)
library(broom)
library(MuMIn)
library(knitr)
library(hier.part)
library(patchwork)

# resolutions
rlns <- c("1km", "5km", "10km", "25km", "50km", "100km")

# study extent (for MENE this is England)
study_ext_sf <- st_read("~/DATA/ADMINISTRATIVE/gb_shapefile/GBR_adm1.shp", quiet = TRUE) %>% 
  filter(NAME_1 == "England") %>% 
  st_transform(crs = 3035)

study_ext <- as(study_ext_sf, "Spatial")

theme_set(theme_bw(base_size = 10) + theme(strip.background = element_blank(), 
                             panel.grid.major = element_blank(),
                             panel.grid.minor = element_blank()))
```

## Data collating

We're making one big dataframe of the response (MENE visits) and  covariates (proportion of non-built land covers, land-cover diversity, mean elevation, topographic variation and population density) at each of the analysis resolutions. 

```{r get_data}
get_df <- function(rln) {
  # list all files of specified resolution
  fnames <- list.files("data/covariates", pattern = paste0("_", rln), full.names = TRUE)
  fnames <- c(fnames, paste0("data/response/mene_", rln, ".tif"))
  
  # stack them
  dat <- stack(fnames)
  
  # crop and mask by study extent - mask will get rid of most of the coastal cells
  # NB need to find out what rule mask actually applies
  dat <- crop(dat, study_ext)
  dat <- mask(dat, study_ext)
  
  # get into a dataframe
  df <- as.data.frame(dat, xy = TRUE) %>% 
    rename_all(funs(str_replace_all(., paste0("_", rln), ""))) %>% 
    na.omit %>% 
    mutate(resolution = rln)
  
  return(df)
}

# dataframe with obs for all data
df <- map_dfr(rlns, get_df) %>% 
  mutate(resolution = factor(resolution, 
                             levels = c("1km", 
                                        "5km", 
                                        "10km", 
                                        "25km", 
                                        "50km", 
                                        "100km")))
```

## Data exploration

First, let's just see whether there is sufficient variability and n in each resolution to fit models. 

```{r mene_distribution}
ggplot(df, aes(x = mene)) + 
  geom_histogram() + 
  facet_wrap(~resolution, scales = "free")
```

```{r mene_n}
df %>% 
  group_by(resolution) %>% 
  summarise(count = n())
```

Based on the distributions, we can fit models for all resolutions, but for the larger two (50km and 100km), n is very small. 

We can also inspect the spatial coverage of the MENE data. 

```{r mene_spatial}
ggplot(df, aes(x = x, y = y)) + 
  geom_raster() + 
  coord_equal() + 
  facet_wrap(~resolution) + 
  theme(axis.title = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank())
```

Sparse coverage at 1km and 5km, but not too geographically biased. There are a lot of records around London, and to some extent within National Parks. This may cause some issues, but will see. 

Finally, lets look at the relationships between variables:

```{r var_relationships, fig.width = 10}
p <- list()
for(r in rlns) {
  p[[r]] <- ggpairs(df %>% filter(resolution == r) %>% dplyr::select(-resolution, -x, -y, -clc_prop), progress = FALSE)
}

p
```

MENE most strongly correlated with:

- 1km: agriculture (-ve) and population (+ve)
- 5km: agriculture (-ve), population and amenity (+ve)
- 10km: agriculture (-ve), LC diversity, population and amenity (+ve)
- 25km: agriculture (-ve), LC diversity, population and amenity (+ve)
- 50km: agriculture (-ve), LC diversity, vegetated LC, population and amenity (+ve)
- 100km: agriculture and water (-ve), LC diversity, population and amenity (+ve)

- amenity and population are correlated at all resolutions: amenity will not be included in the model. 


## Statistical Models

```{r mene_mods}
fit_mod <- function(dat) {
  glm(mene ~ clc_agri + clc_forest + clc_shei + clc_veg + clc_water + clc_wetland + pop,
      family = "poisson",
      data = dat)
}

part_var <- function(dat) {
  resp <- dat %>% pull(mene)
  pred <- dat %>% dplyr::select(clc_agri, clc_forest, clc_shei, clc_water, clc_wetland, pop)
  
  part <- hier.part(resp, pred, family = "poisson", gof = "Rsqu", barplot = FALSE)$I.perc
  
  out <- tibble(var = rownames(part), expl = part$I)
}

scale_cols <- function(x) {
  scale_this <- function(y) as.vector(scale(y))
  #x <- x %>% mutate(pop = log(pop + 1))
  mutate_at(x, .vars = vars(-mene), .funs = funs(scale_this))
}

# get the CA function
source("../upscaling/R/ca_glm.R")

# get all of the required stats
get_mod_stats <- function(mod) {
  coeff <- coef(mod)[-1] %>% 
    data.frame %>% 
    as_tibble(rownames = "variable") %>% 
    rename(coef = 2)
  
  conf <- confint(mod)[-1,] %>% 
    data.frame %>% 
    as_tibble(rownames = "variable") %>% 
    rename(lci = X2.5.., uci = X97.5..)
  
  ca <- calc_commonality(mod)$CCTotalbyVar %>% 
    as_tibble(rownames = "variable")
  
  out <- inner_join(coeff, conf) %>% 
    inner_join(ca) %>% 
    mutate(
      r_s = map_dbl(variable, function(x) {
        out <- cor(model.matrix(mod)[,x], mod$fitted.values)
      }),
      r_s2 = r_s^2)
  
  return(out)
}

mod <- df %>% 
  group_by(resolution) %>% 
  nest() %>% 
  mutate(data_scaled = map(data, scale_cols),
         mod = map(data_scaled, fit_mod),
         mod_glance = map(mod, glance),
         mod_stats = map(mod, get_mod_stats),
         mod_part = map(data_scaled, part_var),
         mod_resid = map(mod, resid),
         mod_fitted = map(mod, fitted))

mod_D2 <- mod %>%
  dplyr::select(resolution, mod_glance) %>% 
  unnest() %>% 
  mutate(D2 = (null.deviance - deviance)/null.deviance) %>% 
  dplyr::select(resolution, D2)

mod_part <- mod %>% 
  dplyr::select(resolution, mod_part) %>% 
  unnest()

mod_stats <- mod %>%
  dplyr::select(resolution, mod_stats) %>% 
  unnest()
```

TODO: Testing residuals with DHARMa showed overdispersion with strong patterns in the residuals for CLC and POP. Would be worth fitting a quadratic term for each of these. Even with population logged, there are some low population cells (even at 100km level) with high residual values. 

How well do they fit? NB We are using $D^2$, which is equivalent to $R^2$ [@Guisan2000a]. Note also that due to the differences in sample size, $D^2$ values are not directly comparable.

```{r}
ggplot(mod_D2, aes(x = resolution, y = D2, group = 1)) + 
  geom_point() + 
  stat_summary(fun.y=sum, geom="line")
```

Explanatory power of the model increases greatly between 1km and 5km resolutions (with increasing explanatory power as resolution increases, as to be expected). Might be best to drop the 1km model. 

What about the relative importances?

NB This plot shows the proportion of variance explained by each variable of the total variance explained. It's greater than 1 because there are shared explained variances

```{r}
p1 <- ggplot(mod_D2, aes(x = resolution, y = D2)) + 
  geom_bar(stat = "identity") + 
  labs(x = "", y = expression(D^{2})) + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

p2 <- ggplot(mod_part, aes(x = resolution, y = expl, fill = var)) + 
  scale_fill_viridis_d(name = "Variable") + 
  geom_bar(stat = "identity", position = "stack") + 
  labs(x = "Resolution", y = "Variance explained %")

p1 + p2 + 
  plot_layout(ncol = 1, heights = c(1, 3)) + 
  plot_annotation(tag_levels = "a", tag_suffix = ")")
```

- Importance of population increases slightly with spatial resolution. This explains the most variation in all cases
- Importance of agriculture decreases with spatial resolution
- wetland and habitat diversity become more important with increasing spatial resolution, but not to much of an extent. 

- We can also view as categories - here yellow is demand, everything else is supply. Importance of demand increases with spatial resolution before decreasing at 100m resolution. 

What about the relationships?

```{r}
ggplot(mod_stats, aes(x = resolution, y = coef)) + 
  geom_point() + 
  geom_hline(yintercept = 0) + 
  geom_errorbar(aes(ymin = lci, ymax = uci)) + 
  facet_wrap(~variable, nrow = 1)
```

Some scale dependencies. Probably need to check they are not entirely statistical artefacts. 

## Bright & dark spots

Following Frei et al. [-@Frei2018] and Cinner et al. [-@Cinner2016], we calculate bright spots and dark spots. We define bright/dark spots as those where the observed value is +/- 1SD (of observed values) from the expected value. 

```{r, fig.width = 15, fig.height = 10}
bd_spots <- mod %>% 
  dplyr::select(resolution, data, mod_fitted, mod_resid) %>% 
  unnest() %>% 
  group_by(resolution) %>% 
  mutate(diff = mod_fitted - mene,
         bd_spots = case_when(diff < -sd(mene) ~ "Dark",
                               diff > sd(mene) ~ "Bright",
                               TRUE ~ "Neutral"))

# potentially explanatory spatial layers
# np <- st_read("~/DATA/ADMINISTRATIVE/national_parks_england/National_Parks_England.shp",
#               quiet = TRUE) %>%
#   st_transform(st_crs(study_ext_sf))
# 
# aonb <- st_read("~/DATA/ADMINISTRATIVE/aonb_england/Areas_of_Outstanding_Natural_Beauty_England.shp",
#                 quiet = TRUE) %>%
#   st_transform(st_crs(study_ext_sf))

cities <- st_read("~/DATA/ADMINISTRATIVE/uk_cities/Major_Towns_and_Cities_December_2015_Boundaries.shp",
                  quiet = TRUE) %>%
  st_transform(st_crs(study_ext_sf)) %>%
  st_centroid %>%
  filter(tcity15nm %in% c("Birmingham", "Leeds", "London", "Manchester", "Newcastle upon Tyne"))

ggplot() + 
  geom_raster(data = bd_spots, 
              aes(x = x, y = y, fill = bd_spots)) + 
  #geom_sf(data = np, colour = "black", fill = NA) + 
  #geom_sf(data = aonb, colour = "black", fill = NA) + 
  geom_sf(data = cities, colour = "black", fill = NA) + 
  geom_sf(data = study_ext_sf, fill = NA) + 
  facet_wrap(~resolution) + 
  scale_fill_manual(values = c("orange", "blue", "grey")) + 
  theme(axis.title = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank())
```

Cities marked out: London, Birmingham, Manchester, Leeds, Newcastle upon Tyne.  
```{r}
ggplot(bd_spots, aes(x = mod_fitted, y = mene)) + 
  geom_point(aes(colour = bd_spots)) + 
  scale_colour_manual(values = c("orange", "blue", "grey")) + 
  geom_smooth(method = "lm") + 
  facet_wrap(~resolution, scales = "free")
```

This pretty much shows that 1km is a poorly fitting model, need more bespoke approaches at this scale? 

Scale dependency in the % of bright/dark spots?

```{r}
bd_summary <- group_by(bd_spots, resolution) %>% 
  summarise(Bright = sum(bd_spots == "Bright"),
            Dark = sum(bd_spots == "Dark"),
            Total = n(),
            `Bright %` = (Bright/Total)*100,
            `Dark %` = (Dark/Total)*100) %>% 
  gather(key, value, -resolution, -Bright, -Dark, -Total)

ggplot(bd_summary, aes(x = resolution, y = value, colour = key, group = key)) + 
  geom_point() + 
  scale_colour_manual(values = c("orange", "blue", "grey")) + 
  stat_summary(fun.y=sum, geom="line") + 
  ylab("% of total area")
```

I'm not sure that this plot is useful - I think this just tells us the same as the increasing $R^2$. 

## Hot & cold spots

These are the areas of maximum and minimum service provision. I'm defining hot/cold spots as those cells in the top/bottom 5%. 

I'm not 100% convinced by this because of the skewed distribution. 

```{r}
hc_spots <- df %>% 
  group_by(resolution) %>% 
  mutate(hc_spots = case_when(mene < quantile(mene, 0.1) ~ "Cold",
                               mene > quantile(mene, 0.9) ~ "Hot",
                               TRUE ~ "Neutral"))
```

```{r}
ggplot() + 
  geom_raster(data = hc_spots, 
              aes(x = x, y = y, fill = hc_spots)) + 
  #geom_sf(data = np, colour = "black", fill = NA) + 
  #geom_sf(data = aonb, colour = "black", fill = NA) + 
  geom_sf(data = cities, colour = "black", fill = NA) + 
  geom_sf(data = study_ext_sf, fill = NA) + 
  facet_wrap(~resolution) + 
  scale_fill_manual(values = c("blue", "orange", "grey")) + 
  theme(axis.title = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank())
```

Problem in that coastal areas come out as cold spots, but that's an area thing. Might need to remove cells which are not 100% on land. 

Scale dependency in the % of hot/cold spots?

```{r}
hc_summary <- group_by(hc_spots, resolution) %>% 
  summarise(Hot = sum(hc_spots == "Hot"),
            Cold = sum(hc_spots == "Cold"),
            Total = n(),
            `Hot %` = (Hot/Total)*100,
            `Cold %` = (Cold/Total)*100) %>% 
  gather(key, value, -resolution, -Hot, -Cold, -Total)

ggplot(hc_summary, aes(x = resolution, y = value, colour = key, group = key)) + 
  geom_point() + 
  scale_colour_manual(values = c("blue", "orange", "grey")) + 
  stat_summary(fun.y=sum, geom="line") + 
  ylab("% of total area")
```

## References

## Session Info

```{r session_info}
session <- devtools::session_info()
session[[1]]
session[[2]] %>% kable
```