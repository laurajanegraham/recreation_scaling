---
title: "Process Covariate Data"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
```

```{r load_packages}
# Libraries
library(raster)
library(rgdal)
library(tidyverse)
library(gdalUtils)
library(doParallel)
library(knitr)

# Analysis resolutions
rln <- c(5, 10, 25, 50)

# Calculate the number of cores
no_cores <- detectCores() - 1

# study extent
study_ext_sf <- st_read("~/DATA/ADMINISTRATIVE/gb_shapefile/GBR_adm1.shp", quiet = TRUE) %>% 
  filter(NAME_1 == "England") %>% 
  st_transform(crs = 3035)

study_ext <- as(study_ext_sf, "Spatial")
```

## General details

We are creating a dataset of social-ecological covariates at a range of spatial resolutions: 5km, 10km, 25km, 50km. All data are open. 

## Elevation data

We use [EU-DEM v1.1](https://land.copernicus.eu/pan-european/satellite-derived-products/eu-dem/eu-dem-v1.1/view) at 100m resolution to calculate topographic variability at each resolution. Note that we are using a version that we previously aggregated (mean) to 100m resolution to reduce processing time. We may wish to revisit. 

```{r dem_data}
dem <- raster("~/DATA/PHYSICAL/elev/eu_dem_1.1/eudem_100m_aggregated.tif")
```

```{r dem_var}
# Initiate cluster
cl <- makeCluster(no_cores)
clusterExport(cl, c("dem"))
clusterEvalQ(cl, "raster")

# aggregate to each resolution
out <- parLapply(cl, rln, function(x) {
  fname <- paste0("data/dem_var_", x, "km.tif")
  raster::aggregate(dem, (x*1000)/100, 
            fun=var, 
            filename = fname,
            overwrite = TRUE)
})

stopCluster(cl)
```

```{r dem_mean}
# Initiate cluster
cl <- makeCluster(no_cores)
clusterExport(cl, c("dem"))
clusterEvalQ(cl, "raster")

out <- parLapply(cl, rln, function(x) {
  fname <- paste0("data/dem_mean_", x, "km.tif")
  raster::aggregate(dem, (x*1000)/100, 
            fun=mean, 
            filename = fname,
            overwrite = TRUE)
})

stopCluster(cl)
```

```{r dem_range}
# Initiate cluster
cl <- makeCluster(no_cores)
clusterExport(cl, c("dem"))
clusterEvalQ(cl, "raster")

# aggregate to each resolution
out <- parLapply(cl, rln, function(x) {
  fname <- paste0("data/dem_range_", x, "km.tif")
  raster::aggregate(dem, (x*1000)/100, 
            fun=function(y, ...) max(y) - min(y), 
            filename = fname,
            overwrite = TRUE)
})

stopCluster(cl)
```

## Land-cover data

We use [Corine Land Cover 2012](https://land.copernicus.eu/pan-european/corine-land-cover/clc-2012) at 100m resolution to calculate land-cover proportions and diversity at each resolution. 

```{r clc_data}
align_rasters(unaligned = "C:/Users/lg1u16/DATA/LULC/clc2012/g100_clc12_V18_5.tif", 
              reference = "C:/Users/lg1u16/DATA/PHYSICAL/elev/eu_dem_1.1/eudem_100m_aggregated.tif",
              dstfile = "data/covariates/clc_100m.tif",
              r = "mode",
              nThreads = "ALL_CPUS",
              overwrite = TRUE)
```

```{r clc_dataload}
clc <- raster("data/covariates/clc_100m.tif")
```

### Land-cover diversity

```{r clc_shei}
# Initiate cluster
cl <- makeCluster(no_cores)
clusterExport(cl, c("clc"))
clusterEvalQ(cl, c("raster", "grainchanger"))

# aggregate to each resolution
out <- parLapply(cl, rln, function(x) {
  fname <- paste0("data/covariates/clc_shei_", x, "km.tif")
  raster::aggregate(clc, (x*1000)/100, 
            fun=function(y, ...) grainchanger::diversity(y, lc_class = 1:44), 
            filename = fname,
            overwrite = TRUE)
})

stopCluster(cl)
```

### Proportion of amenity land cover

- green urban areas (10)
- sport and leisure facilities (11)

```{r clc_amenity}
cl <- makeCluster(no_cores)
clusterExport(cl, c("clc"))
clusterEvalQ(cl, c("raster"))

out <- parLapply(cl, rln, function(x) {
  fname <- paste0("data/covariates/clc_amenity_", x, "km.tif")
  raster::aggregate(clc, (x*1000)/100, 
            fun=function(y, ...) sum(y %in% 10:11), 
            filename = fname,
            overwrite = TRUE)
})

stopCluster(cl)
```

### Proportion of agricultural land cover

- classes 12 to 21. This includes all land-cover types associated with agriculture regardless of intensity.

```{r clc_agri}
cl <- makeCluster(no_cores)
clusterExport(cl, c("clc"))
clusterEvalQ(cl, c("raster"))

out <- parLapply(cl, rln, function(x) {
  fname <- paste0("data/covariates/clc_agri_", x, "km.tif")
  raster::aggregate(clc, (x*1000)/100, 
            fun=function(y, ...) sum(y %in% 12:21), 
            filename = fname,
            overwrite = TRUE)
})

stopCluster(cl)
```

### Proportion of forested land cover

- agro-forestry areas (22)
- broad-leaved forest (23)
- coniferous forest (24)
- mixed forest (25)

```{r clc_forest}
cl <- makeCluster(no_cores)
clusterExport(cl, c("clc"))
clusterEvalQ(cl, c("raster"))

out <- parLapply(cl, rln, function(x) {
  fname <- paste0("data/covariates/clc_forest_", x, "km.tif")
  raster::aggregate(clc, (x*1000)/100, 
            fun=function(y, ...) sum(y %in% 22:25), 
            filename = fname,
            overwrite = TRUE)
})

stopCluster(cl)
```

### Proportion of other vegetated land covers

- natural grasslands (26)
- moors and heathland (27)
- sclerophyllous vegetation (28)
- transitional woodland-shrub (29)

```{r clc_veg}
cl <- makeCluster(no_cores)
clusterExport(cl, c("clc"))
clusterEvalQ(cl, c("raster", "grainchanger"))

out <- parLapply(cl, rln, function(x) {
  fname <- paste0("data/covariates/clc_veg_", x, "km.tif")
  raster::aggregate(clc, (x*1000)/100, 
            fun=function(y, ...) sum(y %in% 26:29), 
            filename = fname,
            overwrite = TRUE)
})

stopCluster(cl)
```

### Proportion of wetland land covers

- inland marshes (35)
- peat bogs (36)
- salt marshes (37)
- salines (38)
- intertidal flats (39)

```{r clc_wetland}
cl <- makeCluster(no_cores)
clusterExport(cl, c("clc"))
clusterEvalQ(cl, c("raster", "grainchanger"))

out <- parLapply(cl, rln, function(x) {
  fname <- paste0("data/covariates/clc_wetland_", x, "km.tif")
  raster::aggregate(clc, (x*1000)/100, 
            fun=function(y, ...) sum(y %in% 35:39), 
            filename = fname,
            overwrite = TRUE)
})

stopCluster(cl)
```


### Proportion of water bodies

- water courses (40)
- water bodies (41)
- coastal lagoons (42)
- estuaries (43)
- sea and ocean (44)

```{r clc_water}
cl <- makeCluster(no_cores)
clusterExport(cl, c("clc"))
clusterEvalQ(cl, c("raster", "grainchanger"))

out <- parLapply(cl, rln, function(x) {
  fname <- paste0("data/covariates/clc_water_", x, "km.tif")
  raster::aggregate(clc, (x*1000)/100, 
            fun=function(y, ...) sum(y %in% 40:44), 
            filename = fname,
            overwrite = TRUE)
})

stopCluster(cl)
```

## Population data

We use [Population density disaggregated with Corine land cover 2000](https://www.eea.europa.eu/data-and-maps/data/population-density-disaggregated-with-corine-land-cover-2000-2) at 100m resolution to calculate total population at each resolution. 

```{r pop_data, eval = FALSE}
align_rasters(unaligned = "C:/Users/lg1u16/DATA/SOCIAL/EEA_gridded_population/popu01clcv5.tif", 
                     reference = "C:/Users/lg1u16/DATA/PHYSICAL/elev/eu_dem_1.1/eudem_100m_aggregated.tif",
                     dstfile = "data/covariates/pop_100m.tif",
                     nThreads = "ALL_CPUS")
```

```{r pop_total}
pop <- raster("data/covariates/pop_100m.tif")

# Initiate cluster
cl <- makeCluster(no_cores)
clusterExport(cl, c("pop"))
clusterEvalQ(cl, "raster")

# aggregate to each resolution
out <- parLapply(cl, rln, function(x) {
  fname <- paste0("data/covariates/pop_", x, "km.tif")
  raster::aggregate(pop, (x*1000)/100, 
            fun=sum, 
            filename = fname,
            overwrite = TRUE)
})

stopCluster(cl)
```

## Protected area data

We calculate the total amount of area designated as [National Park](https://data.gov.uk/dataset/334e1b27-e193-4ef5-b14e-696b58bb7e95/national-parks-england) or [Area of Outstanding Natural Beauty](https://data.gov.uk/dataset/8e3ae3b9-a827-47f1-b025-f08527a4e84e/areas-of-outstanding-natural-beauty-england) at each resolution. We use the data from Natural England.

```{r pa}
eu_crs <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"

shp<- rbind(st_read("~/DATA/ADMINISTRATIVE/national_parks_england/National_Parks_England.shp") 
            %>% select(NAME),
            st_read("~/DATA/ADMINISTRATIVE/aonb_england/Areas_of_Outstanding_Natural_Beauty_England.shp") 
            %>% select(NAME)) %>% 
  st_transform(eu_crs)


for(x in rln) {
  ras <- raster(paste0("data/covariates/pop_", x, "km.tif"))
  ras <- crop(ras, study_ext)
  g <- as(ras, 'SpatialPolygonsDataFrame') %>% st_as_sf() %>% mutate(id = 1:n())
  int <- as_tibble(st_intersection(shp, g))
  int <- int %>% mutate(area_pa = st_area(geometry))
  
  pa_cell <- int %>%
    group_by(id) %>%
    summarise(area_pa = sum(area_pa)/((x*1000)^2)) %>% 
    right_join(g) %>% 
    mutate(area_pa = case_when(is.na(area_pa) ~ 0,
                               TRUE ~ as.numeric(area_pa))) %>% 
    st_as_sf()
  
  ras_out <- fasterize::fasterize(pa_cell, ras, field = "area_pa")
  writeRaster(ras_out, filename = paste0("data/covariates/pa_", x, "km.tif"))
}
```

## Distance to city data

Data on major towns and cities from [ONS](https://data.gov.uk/dataset/7879ab82-2863-401e-8a29-a56e264d2182/major-towns-and-cities-december-2015-boundaries). 

```{r dist}
cities <- st_read("~/DATA/ADMINISTRATIVE/uk_cities/Major_Towns_and_Cities_December_2015_Boundaries.shp") %>% 
  st_transform(eu_crs) %>% 
  st_centroid()

for(x in rln) {
  ras <- raster(paste0("data/covariates/pop_", x, "km.tif"))
  ras <- crop(ras, study_ext)
  g <- as(ras, 'SpatialPolygonsDataFrame') %>% st_as_sf() %>% mutate(id = 1:n())
  pts <- g %>% st_centroid()
  dists <- g %>% mutate(dist = st_distance(pts, cities) %>% apply(1, min))
  ras_out <- fasterize::fasterize(dists, ras, field = "dist")
  writeRaster(ras_out, filename = paste0("data/covariates/dist_", x, "km.tif"))
}
```

## Session Info

```{r session_info}
session <- devtools::session_info()
session[[1]]
session[[2]] %>% kable
```