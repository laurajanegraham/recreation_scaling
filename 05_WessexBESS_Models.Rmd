---
title: "Wessex BESS Models"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
```

```{r load_packages}
library(MASS)
library(raster)
library(sf)
library(tidyverse)
library(GGally)
library(broom)
library(MuMIn)
library(knitr)
library(hier.part)
library(patchwork)
library(corrr)
library(jtools)

# resolutions
rlns <- c("1km", "5km", "10km")

theme_set(theme_bw(base_size = 10) + theme(strip.background = element_blank(), 
                             panel.grid.major = element_blank(),
                             panel.grid.minor = element_blank()))

# get the functions I've written for variance partitioning negative binomial models
source("code/hier.part.nb.R")
```

## Data collating

We're making one big dataframe of the response (Wessex BESS recreation visits) and covariates at each of the analysis resolutions. 

Covariates are:

- Proportion of agricultural land cover (clc_agri; supply)
- Proporiton of natural land covers (clc_prop; supply)
- Diversity of land-cover types (clc_shei; supply)
- Mean elevation (dem_mean; supply)


```{r get_data}
get_df <- function(rln) {
  # list all files of specified resolution
  fnames <- list.files("data/covariates", pattern = paste0("_", rln), full.names = TRUE)
  rnames <-paste0("data/response/wbess_", rln, ".tif")
  
  # stack them
  dat <- stack(fnames)
  resp <- raster(rnames)
  dat <- crop(dat, resp)
  dat <- stack(dat, resp)
  # get into a dataframe
  df <- as.data.frame(dat, xy = TRUE) %>% 
    rename_all(funs(str_replace_all(., paste0("_", rln), ""))) %>% 
    na.omit %>% 
    mutate(resolution = rln)
  
  return(df)
}

# dataframe with obs for all data
df <- map_dfr(rlns, get_df) %>% 
  mutate(resolution = factor(resolution, 
                             levels = c("1km", 
                                        "5km", 
                                        "10km")),
         clc_prop = clc_amenity + clc_forest + clc_veg + clc_water + clc_wetland) %>% 
  select(x, y, resolution, wbess, clc_agri, clc_prop, clc_shei, dem_mean, dem_var, pop) %>% 
  as_tibble()
```

## Data exploration

### Distribution, sample size and coverage of MENE data

First, let's just see whether there is sufficient variability and n in each resolution to fit models. 

```{r wbess_distribution, fig.height = 3, fig.width = 8}
ggplot(df, aes(x = wbess)) + 
  geom_histogram() + 
  facet_wrap(~resolution, scales = "free", nrow = 1)

ggplot(df, aes(y = wbess)) + 
  geom_boxplot() + 
  facet_wrap(~resolution, scales = "free", nrow = 1)
```

```{r wbess_n}
df %>% 
  group_by(resolution) %>% 
  summarise(count = n())
```

1km may be problematic due to little variability, 10km may be problematic due to small n. Would like to add in a 2km resolution (which will need to happen across the board. 

```{r wbess_spatial}
ggplot(df, aes(x = x, y = y)) + 
  geom_raster() + 
  coord_equal() + 
  facet_wrap(~resolution) + 
  theme(axis.title = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank())
```

### Distribution of covariates

```{r cov_dist, fig.height = 3, fig.width = 8}
df_narrow <- df %>% 
  select(-x, -y, -wbess) %>% 
  gather(variable, value, -resolution) %>% 
  group_by(variable) %>% 
  nest() %>% 
  mutate(histograms = map2(variable, data, function(variable, data) {
    ggplot(data, aes(x = value)) + 
      geom_histogram() + 
      facet_wrap(~resolution, nrow = 1, scales = "free") +
      ggtitle(variable)
  }),
  boxplots = map2(variable, data, function(variable, data) {
    ggplot(data, aes(y = value)) + 
      geom_boxplot() + 
      facet_wrap(~resolution, nrow = 1, scales = "free") +
      ggtitle(variable)
  }))

df_narrow$histograms
df_narrow$boxplots
```

- clc_agri: left skew
- clc_prop: right skew
- clc_shei: fine
- dem_mean: fine
- dem_var: right skew
- pop: right skew

### Data scaling and transformation

For now, I'm using the same transformations as the MENE study. Might revisit (in particular dem_mean given there are no skew issues).

```{r transform}
df_scaled <- df %>% group_by(resolution) %>% 
  nest() %>% 
  mutate(data = map(data, mutate_at, vars(clc_prop:pop), function(x) log(x + 1)),
         data = map(data, mutate, clc_agri = clc_agri^2),
         data_scale = map(data, mutate_at, vars(clc_agri:pop), function(x) scale(x) %>% as.vector)) 

df_analysis <- df_scaled %>% 
  select(resolution, data_scale) %>% 
  unnest()

# get mean and sd values from the log-transformed data (for back scaling)
means <- df_scaled %>% 
  select(resolution, data) %>% 
  unnest() %>% 
  group_by(resolution) %>% 
  summarise_all(funs(mean, sd)) %>% 
  gather(key, value, -resolution) 
```

### Correlation between variables

```{r cov_corrs, fig.width = 10}
corrs <- df_analysis %>% 
  select(-x, -y) %>% 
  group_by(resolution) %>% 
  nest() %>% 
  mutate(
    corrs = map(data, function(x) {
      x %>% correlate(quiet = TRUE)
    }),
    corrs2 = map(corrs, function(x) {
      x %>% rearrange %>% shave
    })
  )

map(corrs$corrs2, rplot, shape = 15, print_cor = TRUE)
```

There are some high correlations here. Will likely cause issues for 10km analysis. Need to keep an eye on the estimates. Key one to watch out for is clc_prop and clc_agri.

And the relationship with WBESS data: 

```{r wbess_corrs}
map(corrs$corrs, function(x) {
  x %>%
    focus(wbess) %>%
    mutate(rowname = reorder(rowname, wbess)) %>%
    ggplot(aes(rowname, wbess)) +
    geom_col() + 
    coord_flip() + 
    ylim(-1, 1)
})
```

WBESS most strongly correlated with:

- 1km: Variation in elevation land-cover diversity and population (+ve); agriculture (-ve)
- 5km: Population and land-cover diversity (+ve); agriculture and mean elevation (-ve)
- 10km: Population, land-cover diversity and variation in elevation (+ve); agriculture and mean elevation (-ve)

NB all correlations are fairly weak and they are strongest at 5km resolution. 

What are the shapes of the correlations between MENE and covariates:

```{r wbess_corr_shape}
df_analysis %>% 
  select(-x, -y) %>% 
  gather(variable, value, -resolution, -wbess) %>% 
  ggplot(aes(x = value, y = wbess)) + 
  geom_point() + 
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs")) + 
  facet_grid(resolution ~ variable, scales = "free")
```

## Statistical Models

We fit a Poisson glm for each resolution with proportion of agricultural land covers; proportion of natural land covers; diversity of land cover; mean elevation; variation in elevation (NB we do not include this in the MENE model, but it has a reasonable correlation with WBESS); and population as covariates. 

We use variance partitioning to examing the relative importance of each predictor with the model. 

We measure model fit using $D^2$, which is equivalent to $R^2$ [@Guisan2000a]. Note also that due to the differences in sample size, $D^2$ values are not directly comparable.

```{r wbess_mods}
fit_mod_full <- function(dat) {
  glm.nb(wbess ~ clc_agri + clc_prop + clc_shei + dem_mean + dem_var + pop,
      #family = "poisson",
      data = dat)
}

fit_mod_supply <- function(dat) {
  glm.nb(wbess ~ clc_agri + clc_prop + clc_shei + dem_mean + dem_var,
      #family = "poisson",
      data = dat)
}

fit_mod_demand <- function(dat) {
  glm.nb(wbess ~ pop,
      #family = "poisson",
      data = dat)
}

part_var <- function(dat) {
  resp <- dat %>% pull(wbess)
  pred <- dat %>% dplyr::select(clc_agri, clc_prop, clc_shei, dem_mean, pop)
  part <- hier.part(resp, pred, family = "poisson", gof = "logLik", barplot = FALSE)$I.perc
  out <- tibble(var = rownames(part), expl = part$I)
}


part_var_nb <- function(dat) {
  resp <- dat %>% pull(wbess)
  pred <- dat %>% dplyr::select(clc_agri, clc_prop, clc_shei, dem_mean, pop)
  part <- hier.part.nb(resp, pred, gof = "logLik")$I.perc
  out <- tibble(var = rownames(part), expl = part$I)
}

# get all of the required stats
get_mod_stats <- function(mod) {
  coeff <- coef(mod)[-1] %>% 
    data.frame %>% 
    as_tibble(rownames = "variable") %>% 
    rename(coef = 2)
  
  conf <- confint(mod)[-1,] %>% 
    data.frame %>% 
    as_tibble(rownames = "variable") %>% 
    rename(lci = X2.5.., uci = X97.5..)
  
  out <- inner_join(coeff, conf)
  
  return(out)
}

# and now the predicted values for plotting the relationships
get_preds <- function(mod, res) {
  vars <- variable.names(mod)[-1]
  map_dfr(vars, function(variable) {
    var_mean <- means %>% 
      filter(resolution == res, key == paste0(variable, "_mean")) %>% 
      pull(value)
    
    var_sd <- means %>% 
      filter(resolution == res, key == paste0(variable, "_sd")) %>% 
      pull(value)
    
    preds <- make_predictions(mod, pred = variable, interval = TRUE)$predicted %>% 
      select(wbess, pred = !!variable, ymin, ymax) %>% 
      mutate(pred = pred*var_sd + var_mean,
             pred = case_when(variable == "clc_agri" ~ sqrt(pred),
                              TRUE ~ exp(pred) - 1),
             variable = variable) %>% 
      na.omit()
    
    return(preds)
  })
}

mod <- df_analysis %>% 
  group_by(resolution) %>% 
  nest() %>% 
  mutate(mod_full = map(data, fit_mod_full),
         mod_supply = map(data, fit_mod_supply),
         mod_demand = map(data, fit_mod_demand),
         mod_glance = map(mod_full, glance),
         mod_stats = map(mod_full, get_mod_stats),
         mod_part = map(data, part_var_nb),
         mod_resid = map(mod_full, resid),
         mod_fitted = map(mod_full, function(x) x$fitted),
         mod_preds = map2(mod_full, resolution, get_preds))

mod_D2 <- mod %>%
  dplyr::select(resolution, mod_glance) %>% 
  unnest() %>% 
  mutate(D2 = (null.deviance - deviance)/null.deviance) %>% 
  dplyr::select(resolution, D2)

mod_part <- mod %>% 
  dplyr::select(resolution, mod_part) %>% 
  unnest()

mod_stats <- mod %>%
  dplyr::select(resolution, mod_stats) %>% 
  unnest()

mod %>%
  mutate(mod_full_aic = map_dbl(mod_full, function(x) x$aic),
         mod_demand_aic = map_dbl(mod_demand, function(x) x$aic),
         mod_supply_aic = map_dbl(mod_supply, function(x) x$aic)) %>% 
  select(resolution, mod_full_aic, mod_demand_aic, mod_supply_aic) %>% 
  kable()
```

At all resolutions, the demand model is best performing as judged by AIC. We still present the full model results for comparison against other data types. 

### Model Fit

```{r}
ggplot(mod_D2, aes(x = resolution, y = D2, group = 1)) + 
  geom_point() + 
  stat_summary(fun.y=sum, geom="line")
```

Explanatory power is best at 5km, poor at 1km and 10km. 

### Variance partitioning

Using package `hier.part`

```{r}
p1 <- ggplot(mod_D2, aes(x = resolution, y = D2)) + 
  geom_bar(stat = "identity") + 
  labs(x = "", y = expression(D^{2})) + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

p2 <- ggplot(mod_part, aes(x = resolution, y = expl, fill = var)) + 
  scale_fill_brewer(palette = "Set1", name = "Variable") + 
  geom_bar(stat = "identity", position = "stack") + 
  labs(x = "Resolution", y = "Variance explained %")

p1 + p2 + 
  plot_layout(ncol = 1, heights = c(1, 3)) + 
  plot_annotation(tag_levels = "a", tag_suffix = ")")
```

- Reasonably stable across spatial resolutions. Importance of land-cover diversity greatst at 1km, this is replaced by increased importance of mean elevation and proportion of natural land covers at 10km. 

### Variable relationships

```{r coeff_plots, fig.height = 5, fig.width=8}
mod_preds <- mod %>%
  select(resolution, mod_preds) %>% 
  unnest() %>% 
  group_by(resolution, variable) %>% 
  ungroup() %>% 
  group_by(resolution) %>% 
  nest() %>% 
  mutate(plots = map2(data, resolution, function(dat, res) {
    ggplot(dat, aes(x = pred, y = wbess)) +
      geom_line(aes()) + 
      geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) +
      facet_wrap(~variable, nrow = 1, scale = "free_x") + 
      ggtitle(res)
  }))
  
mod_preds$plots[[1]] + mod_preds$plots[[2]] + mod_preds$plots[[3]] + plot_layout(ncol = 1)
```

### Model checking

```{r}
library(DHARMa)
for(i in 1:3) {
  print(mod$resolution[[i]])
  simulationOutput <- simulateResiduals(fittedModel = mod$mod_full[[i]], n = 250)
  par(mfrow=c(1,1))
  plot(simulationOutput)
  testDispersion(simulationOutput, alternative = "greater")
  par(mfrow=c(2, 3))
  plotResiduals(mod$data[[i]]$clc_agri, simulationOutput$scaledResiduals, xlab = "clc_agri")
  plotResiduals(mod$data[[i]]$clc_prop, simulationOutput$scaledResiduals, xlab = "clc_prop")
  plotResiduals(mod$data[[i]]$clc_shei, simulationOutput$scaledResiduals, xlab = "clc_shei")
  plotResiduals(mod$data[[i]]$dem_mean, simulationOutput$scaledResiduals, xlab = "dem_mean")
  plotResiduals(mod$data[[i]]$pop, simulationOutput$scaledResiduals, xlab = "pop")
}

```

Model conforms to assumptions well for 5km resolution, 1km and 10km are poor. 

## Bright & dark spots

Following Frei et al. [-@Frei2018] and Cinner et al. [-@Cinner2016], we calculate bright spots and dark spots. We define bright/dark spots as those where the observed value is +/- 1SD (of observed values) from the expected value. 

```{r, fig.width = 15, fig.height = 10}
bd_spots <- mod %>% 
  dplyr::select(resolution, data, mod_fitted, mod_resid) %>% 
  unnest() %>% 
  group_by(resolution) %>% 
  mutate(diff = mod_fitted - wbess,
         bd_spots = case_when(diff < -sd(wbess) ~ "Dark",
                               diff > sd(wbess) ~ "Bright",
                               TRUE ~ "Neutral"))

ggplot() + 
  geom_raster(data = bd_spots, 
              aes(x = x, y = y, fill = bd_spots)) + 
  facet_wrap(~resolution) + 
  scale_fill_manual(values = c("orange", "blue", "grey")) + 
  coord_equal() + 
  theme(axis.title = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank())
```

```{r}
ggplot(bd_spots, aes(x = mod_fitted, y = wbess)) + 
  geom_point(aes(colour = bd_spots)) + 
  scale_colour_manual(values = c("orange", "blue", "grey")) + 
  geom_smooth(method = "lm") + 
  facet_wrap(~resolution, scales = "free")
```

## References

## Session Info

```{r session_info}
session <- devtools::session_info()
session[[1]]
session[[2]] %>% kable
```