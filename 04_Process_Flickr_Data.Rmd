---
title: "Download and process Flickr data"
output: github_document
bibliography: C:/Users/lg1u16/DATA/BIBLIOGRAPHY/library.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
```

```{r load_packages}
# Libraries
library(raster)
library(tidyverse)
library(knitr)
library(sf)
library(lubridate)
library(furrr)

source("code/flickr.R")
```


## Flickr photo data

There are a couple of options. 

1. The approach used by InVEST [@Wood2013g], where all 'photo user days' are included. I worry that this will include a lot of non-recreational photos and bias the results towards cities, although their paper found good correlation between photo user days and income from recreation (but this included non-natural rec). NB I also had difficulties getting the InVEST software to download images over a large area.  

2. An approach where photos are filtered using keywords in a number of languages [@VanZanten2014]. The keywords are included in the supplementary materials for this paper. We can use the in development [flickr](https://github.com/FrancescaMancini/FlickrAPI_EABhackathon) package for R, 

Start with option 2. 

I'm going to start with just England for the years 2009-2017 to be comparable to the MENE data. 

These are lists of keywords from [@VanZanten2014]. They filtered photos that contained at least one of both kw_landscape and kw_ambig, and all keywords from kw_unambig. Best way to do this would be to get all photos from one set (e.g. kw_landscape), and then use `stringr` to filter the tags to ensure at least one of kw_ambig is contained in the tags). 

```{r keywords}
kw_landscape <- c("nature", "landscape", 
                  "cultural landscape", "cultural land", "hill",
                  "mountain", "valley", "basin", "highland",
                  "ridge", "cliff", "peak", "gorge",
                  "glacier", "beach", "shore", "coast",
                  "sea", "ocean", "wetland", "river", "dike",
                  "brook", "lake", "waterfall", "dune",
                  "swamp", "pond", "ditch", "channel",
                  "estuary", "creek", "forest", "tree",
                  "woods", "canopy", "grove", "hedgerow",
                  "bush", "meadow", "grassland", "pasture",
                  "countryside", "prairie", "maize",
                  "corn", "wheat", "oats", "livestock", "cattle",
                  "cow"," sheep", "orchard", "field",
                  "vineyard", "crops", "cropland", "grazing",
                  "heather", "heath", "heathland",
                  "park", "peat", "peatland", "peatbog",
                  "marsh", "marshes", "marshland",
                  "moor", "moors", "moorland", "shrubs",
                  "shrubland")

kw_ambig <- c("relax", "cruising", "relaxing", "beauty",
              "beautiful", "magnificence", "magnificent",
              "splendour", "brilliance", "brilliant",
              "inspiring", "inspired", "sublime",
              "gorgeous", "outstanding", "enjoying",
              "breathtaking", "enchanting")

kw_unambig <- c("walk", "walking", "hike", "hiking",
                "camp", "camping", "recreation", "cycling",
                "horse riding", "fishing", "mountain biking", 
                "bike riding", "run", "running",
                "hunt", "hunting", "tourism",
                "climbing", "trekking", "mountaineering",
                "skiing", "sailing", "rowing", "jogging",
                "outdoor", "vista", "panorama",
                "scene", "scenic", "scenery", "view",
                "viewpoint", "heritage", "historic value")
```

```{r get_photos, message = FALSE}
for(kw in kw_unambig) {
  print(kw)
  p <- photo_by_tag(year_range = c(2009, 2017),
                    tags = kw,
                    woe_id = 24554868)
  save(p, file = paste0("data/flickr/", kw, ".Rda"))
}

for(kw in kw_ambig){
  
  p <- photo_by_tag(year_range = c(2009, 2017),
                    tags = kw,
                    woe_id = 24554868) %>% 
    mutate(photo_tags = str_split(photo_tags, pattern = " "),
           match = map_dbl(photo_tags, function(x) sum(x %in% kw_landscape))) %>% 
    filter(match > 0) %>% 
    select(-match)
  
  save(p, file = paste0("data/flickr/", kw, ".Rda"))
}
```

```{r photo_shp, message = FALSE}
f <- list.files("data/flickr/", full.names = TRUE)

photos_sf <- map_dfr(f, function(x) {
  x %>% load %>% get %>% 
    select(longitude, latitude, owner, datetaken)
  }) %>% 
  mutate(owner_date = paste(owner, date(datetaken), sep="_")) %>% 
  distinct() %>% 
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(crs = 3035)

photos_sp <- as(photos_sf, "Spatial")
```

We need to convert from points to raster at the analysis resolutions. In order to do so, we want the unique owner date combinations. 

```{r photo_rasters}
# loop through the dem files to get rasters for the visits
fnames <- list.files("data/covariates", pattern = "dem_mean", full.names = TRUE)

for(f in fnames) {
  ras <- raster(f)
  rln <- res(ras)/1000
  fname <- paste0("data/response/flickr_", rln[1], "km.tif")
  rec_ras <- rasterize(photos_sp, 
                       ras, 
                       'owner_date', 
                       fun=function(x,...)length(unique(x)), 
                       filename = fname,
                       overwrite = TRUE)
}
```

## Session Info

```{r session_info}
session <- devtools::session_info()
session[[1]]
session[[2]] %>% kable
```